# Summary
## 目录
* 多线程（Thread）
    * 线程池（ThreadPool）
    * 异步编程模型（APM）
    * 基于事件的异步模式（EAP）
    * 基于任务的异步模式（TAP）
    * 任务调度器（TaskScheduler）
* 泛型
    泛型兼具可重用性、类型安全性和高效性。泛型类型或方法编译为 Microsoft 中间语言 (MSIL) 时，它包含将其标识为具有类型参数的元数据。如何使用泛型类型的 MSIL 根据所提供的类型参数是值类型还是引用类型而有所不同。使用值类型作为参数首次构造泛型类型时，运行时创建专用的泛型类型，MSIL 内的适当位置替换提供的一个或多个参数。 为每个用作参数的唯一值类型一次创建专用化泛型类型。运行时生成一个专用版 Stack<T> 类，相同类型会重新使用已生成的专用类。对于引用类型，泛型的作用方式略有不同。 首次使用任意引用类型构造泛型类型时，运行时创建一个专用化泛型类型，用对象引用替换 MSIL 中的参数。运行时执行类型膨胀实现。
    * 协变和逆变
* 委托
    指向方法的指针，但类型安全。用 delegate 声明。
    * 协变和逆变
* 事件
    基于委托实现，使用 event 关键字声明。内置 EventHandle<T> 和 EventArgs 类。
* 反射
* 事务
* 公共语言运行时 (CLR)
* 垃圾回收 (GC)
* 内存分配
    * 内存分部
        * 堆栈
            存储值类型实例以及指针引用等编译时的数据, 由操作系统管理, 方法结束时自动释放
        * 托管堆
            * GC Heap: 存储引用类型对象的实例，受 GC 管理分配和回收。实例包含 Type Handle 和 Syncblk Index 信息，分别为 4 byte；
            * Loader Heap: 元数据相关的信息, 每个 Type 的方法表, 如基类型、实现的接口、静态字段、所有的方法。不受 GC 控制。
        * LOH大对象堆 （LOH）
            存储引用类型对象的实例，且对象的实例大于 85000 字节。LOH 堆不会被压缩，只在完全 GC 回收时回收。
* 特性
    有效地将元数据或声明性信息与代码（程序集、类型、方法、属性等）相关联。
* 设计模式
    * 抽象工厂模式
    * 控制反转模式
    * 代理模式
    * 规约模式
    * 仓储模式
    * 面向切面编程
* Asp.Net
    * Http Context
    * Http Handle
* Asp.Net Core
    * Middelware

***  


**FAQ**  
* 泛型实现机制  
    * 运行时类型安全
* 反射实现机制  
* C# 特性和 Java 注解的区别;

* 委托  
* 多线程间调用  
* 任务间传递数据  
* GC回收机制; new 实例; 释放  
    * 释放托管堆中的对象，分为 0~2代，0、1代为暂存代；
* 基于任务的异步编程模型优势？  
    * 任务调度器(TaskScheduler)依赖于底层的线程池引擎。通过局部队列的任务内联化(task inlining)和工作窃取机制可以为我们提升程序性能。
        * CLR线程池引擎维护了一定数量的空闲工作线程以支持工作项的执行，并且能够重用已有的线程以避免创建新的不必要的线程所花费的昂贵的处理过程。并且使用爬山算法（hill-climbing algorithm）检测吞吐量，判断是否能够通过更多的线程来完成更多的工作项。这个算法的判断依据是工作项所需某些类型资源的可用情况，例如：CPU、网络带宽或其他。此外这个算法还会考虑一个饱和点，即达到饱和点的时候，创建更多地线程反而会降低吞吐量。
    * 轻松实现任务等待、任务取消、延续任务、异常处理。
* 异步编程如何等待同步阻塞  
    * TaskComplateSource
* .Net framework 和 .Net core 的并发集合区别  
* 实现 DI, 抽象工厂  